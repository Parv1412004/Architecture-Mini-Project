SIMPLE ISA: Two-Pass Assembler and EmulatorThis project provides a complete toolchain for the SIMPLE instruction set architecture, as specified in the CS210 MiniProject. It includes a robust two-pass assembler that converts SIMPLE assembly code into machine-readable binary object files, and an emulator to execute these files. The entire project is written in C.FeaturesAssembler (asm.c)Two-Pass Design: Implements a two-pass assembly process to correctly resolve forward-referenced labels.Source Code Parsing: Reads and parses SIMPLE assembly language from a standard text file.Symbol Table Management: Accurately assigns values to labels during the first pass.Error Diagnosis: Detects and reports common assembly errors, including:Duplicate label definitionsUndefined labels (no such label)Unknown instruction mnemonicsInvalid number formats or operandsFile Generation:Produces a binary object file containing the final machine code.Produces a human-readable listing file that shows memory addresses, the generated machine code (in hex), and the original instruction mnemonics for clarity.Syntax Support: Correctly handles comments (starting with ;), blank lines, and leading whitespace.Extended Functionality: Implements the SET pseudo-instruction for assigning constant values to labels.Emulator (emu.c)Machine Simulation: Emulates the SIMPLE machine architecture, which includes four 32-bit registers (A, B, SP, PC).Object File Loading: Loads the binary object files generated by the assembler into its simulated memory.Execution Cycle: Fetches, decodes, and executes instructions according to the SIMPLE ISA specification.Program Termination: Halts execution upon encountering the HALT instruction.SIMPLE Architecture OverviewThe SIMPLE machine is a 32-bit architecture with four primary registers:A & B: Two general-purpose registers arranged as an internal stack.SP: A stack pointer.PC: The program counter.Instructions are 32 bits wide, encoded with the lower 8 bits for the opcode and the upper 24 bits for a signed 2's complement operand.Instruction Set Architecture (ISA)The assembler supports the following instructions:MnemonicOpcodeOperandDescriptiondata-valueReserve a memory location, initialized to the value specified.ldc0valueLoad accumulator A with the specified value.adc1valueAdd the specified value to the accumulator.ldl2offsetLoad local value from memory[SP+offset] into A.stl3offsetStore value from A into memory[SP+offset].ldnl4offsetLoad non-local value from memory[A+offset] into A.stnl5offsetStore value from B into memory[A+offset].add6A = B + A.sub7A = B - A.shl8A = B << A.shr9A = B >> A.adj10valueAdjust the stack pointer: SP = SP + value.a2sp11Transfer value from A to SP.sp2a12Transfer value from SP to A.call13offsetCall procedure at PC + offset.return14Return from procedure.brz15offsetBranch to PC + offset if A is zero.brlz16offsetBranch to PC + offset if A is less than zero.br17offsetUnconditional branch to PC + offset.HALT18Stop the emulator.SET-valueSet a label's value to the specified constant.How to Build and RunPrerequisitesA C compiler, such as gcc.CompilationYou can compile the assembler and emulator using gcc directly or by using the provided Makefile.Using GCC:# Compile the assembler
gcc asm.c -o asm

# Compile the emulator
gcc emu.c -o emu
Using Makefile:# Compile both assembler and emulator
make all

# Clean build artifacts
make clean
Usage1. Assembling a ProgramRun the assembler with the source assembly file as an argument. It will produce an object file (.o) and a listing file (.lst)../asm <path/to/your/program.asm>
Example:./asm sample_programs/test1.asm
This will generate sample_programs/test1.o and sample_programs/test1.lst.2. Emulating a ProgramRun the emulator with the generated object file as an argument../emu <path/to/your/program.o>
Example:./emu sample_programs/test1.o
The emulator will then load and execute the machine code.File Structure.
├── asm.c                  # Source code for the assembler
├── emu.c                  # Source code for the emulator
├── Makefile               # Build script for the project
├── sample_programs/       # Directory with example .asm files
│   ├── test1.asm
│   ├── test2_errors.asm
│   └── bubblesort.asm
└── README.md              # This file
