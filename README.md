SIMPLE ISA: Two-Pass Assembler and Emulator
This project provides a complete toolchain for the SIMPLE instruction set architecture, as specified in the CS210 MiniProject. It includes a robust two-pass assembler that converts SIMPLE assembly code into machine-readable binary object files, and an emulator to execute these files. The entire project is written in C.

Features
Assembler (asm.c)
Two-Pass Design: Implements a two-pass assembly process to correctly resolve forward-referenced labels.

Source Code Parsing: Reads and parses SIMPLE assembly language from a standard text file.

Symbol Table Management: Accurately assigns values to labels during the first pass.

Error Diagnosis: Detects and reports common assembly errors, including:

Duplicate label definitions

Undefined labels (no such label)

Unknown instruction mnemonics

Invalid number formats or operands

File Generation:

Produces a binary object file containing the final machine code.

Produces a human-readable listing file that shows memory addresses, the generated machine code (in hex), and the original instruction mnemonics for clarity.

Syntax Support: Correctly handles comments (starting with ;), blank lines, and leading whitespace.

Extended Functionality: Implements the SET pseudo-instruction for assigning constant values to labels.

Emulator (emu.c)
Machine Simulation: Emulates the SIMPLE machine architecture, which includes four 32-bit registers (A, B, SP, PC).

Object File Loading: Loads the binary object files generated by the assembler into its simulated memory.

Execution Cycle: Fetches, decodes, and executes instructions according to the SIMPLE ISA specification.

Program Termination: Halts execution upon encountering the HALT instruction.

SIMPLE Architecture Overview
The SIMPLE machine is a 32-bit architecture with four primary registers:

A & B: Two general-purpose registers arranged as an internal stack.

SP: A stack pointer.

PC: The program counter.

Instructions are 32 bits wide, encoded with the lower 8 bits for the opcode and the upper 24 bits for a signed 2's complement operand.

Instruction Set Architecture (ISA)
The assembler supports the following instructions:

Mnemonic

Opcode

Operand

Description

data

-

value

Reserve a memory location, initialized to the value specified.

ldc

0

value

Load accumulator A with the specified value.

adc

1

value

Add the specified value to the accumulator.

ldl

2

offset

Load local value from memory[SP+offset] into A.

stl

3

offset

Store value from A into memory[SP+offset].

ldnl

4

offset

Load non-local value from memory[A+offset] into A.

stnl

5

offset

Store value from B into memory[A+offset].

add

6



A = B + A.

sub

7



A = B - A.

shl

8



A = B << A.

shr

9



A = B >> A.

adj

10

value

Adjust the stack pointer: SP = SP + value.

a2sp

11



Transfer value from A to SP.

sp2a

12



Transfer value from SP to A.

call

13

offset

Call procedure at PC + offset.

return

14



Return from procedure.

brz

15

offset

Branch to PC + offset if A is zero.

brlz

16

offset

Branch to PC + offset if A is less than zero.

br

17

offset

Unconditional branch to PC + offset.

HALT

18



Stop the emulator.

SET

-

value

Set a label's value to the specified constant.

How to Build and Run
Prerequisites
A C compiler, such as gcc.

Compilation
You can compile the assembler and emulator using gcc directly or by using the provided Makefile.

Using GCC:

# Compile the assembler
gcc asm.c -o asm

# Compile the emulator
gcc emu.c -o emu

Using Makefile:

# Compile both assembler and emulator
make all

# Clean build artifacts
make clean

Usage
1. Assembling a Program
Run the assembler with the source assembly file as an argument. It will produce an object file (.o) and a listing file (.lst).

./asm <path/to/your/program.asm>

Example:

./asm sample_programs/test1.asm

This will generate sample_programs/test1.o and sample_programs/test1.lst.

2. Emulating a Program
Run the emulator with the generated object file as an argument.

./emu <path/to/your/program.o>

Example:

./emu sample_programs/test1.o

The emulator will then load and execute the machine code.

File Structure
.
├── asm.c                  # Source code for the assembler
├── emu.c                  # Source code for the emulator
├── Makefile               # Build script for the project
├── sample_programs/       # Directory with example .asm files
│   ├── test1.asm
│   ├── test2_errors.asm
│   └── bubblesort.asm
└── README.md              # This file
